{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RDF Utilities","text":"<p>Tools for managing RDF resources and common models. See API documentation for more details.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>rdf_utils<ul> <li>caching</li> <li>collection</li> <li>constraints</li> <li>models<ul> <li>common</li> <li>distribution</li> <li>event_loop</li> <li>geometry</li> <li>python</li> </ul> </li> <li>namespace</li> <li>naming</li> <li>resolver</li> <li>uri</li> </ul> </li> </ul>"},{"location":"reference/rdf_utils/","title":"rdf_utils","text":"<p>Modules:</p> <ul> <li> <code>caching</code>           \u2013            <p>Utilites for caching file contents</p> </li> <li> <code>collection</code>           \u2013            </li> <li> <code>constraints</code>           \u2013            </li> <li> <code>models</code>           \u2013            <p>Common processing utilites for RDF graph models</p> </li> <li> <code>namespace</code>           \u2013            <p>Defining namespaces used by RDF models.</p> </li> <li> <code>naming</code>           \u2013            </li> <li> <code>resolver</code>           \u2013            </li> <li> <code>uri</code>           \u2013            </li> </ul>"},{"location":"reference/rdf_utils/caching/","title":"rdf_utils.caching","text":"<p>Utilites for caching file contents</p> <p>Functions:</p> <ul> <li> <code>read_file_and_cache</code>             \u2013              <p>Read and cache string contents of files for quick access and reducing IO operations.</p> </li> <li> <code>read_url_and_cache</code>             \u2013              <p>Read and cache text responses from URL</p> </li> </ul>"},{"location":"reference/rdf_utils/caching/#rdf_utils.caching.read_file_and_cache","title":"read_file_and_cache","text":"<pre><code>read_file_and_cache(filepath)\n</code></pre> <p>Read and cache string contents of files for quick access and reducing IO operations.</p> Note <p>May need \"forgetting\" mechanism if too many large files are stored. Should be fine for loading JSON metamodels and SHACL constraints in Turtle format.</p> Source code in <code>src/rdf_utils/caching.py</code> <pre><code>def read_file_and_cache(filepath: str) -&gt; str:\n    \"\"\"Read and cache string contents of files for quick access and reducing IO operations.\n\n    Note:\n        May need \"forgetting\" mechanism if too many large files are stored. Should be fine\n        for loading JSON metamodels and SHACL constraints in Turtle format.\n    \"\"\"\n    if filepath in __FILE_LOADER_CACHE:\n        return __FILE_LOADER_CACHE[filepath]\n\n    with open(filepath) as infile:\n        file_content = infile.read()\n\n    if isinstance(file_content, bytes):\n        file_content = file_content.decode(\"utf-8\")\n\n    __FILE_LOADER_CACHE[filepath] = file_content\n    return file_content\n</code></pre>"},{"location":"reference/rdf_utils/caching/#rdf_utils.caching.read_url_and_cache","title":"read_url_and_cache","text":"<pre><code>read_url_and_cache(url, timeout=_GLOBAL_DEFAULT_TIMEOUT)\n</code></pre> <p>Read and cache text responses from URL</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>URL to be opened with urllib</p> </li> <li> <code>timeout</code>               (<code>float</code>, default:                   <code>_GLOBAL_DEFAULT_TIMEOUT</code> )           \u2013            <p>duration in seconds to wait for response. Only works for HTTP, HTTPS &amp; FTP.      Default: <code>socket._GLOBAL_DEFAULT_TIMEOUT</code> will be used,      which usually means no timeout.</p> </li> </ul> Source code in <code>src/rdf_utils/caching.py</code> <pre><code>def read_url_and_cache(url: str, timeout: float = _GLOBAL_DEFAULT_TIMEOUT) -&gt; str:\n    \"\"\"Read and cache text responses from URL\n\n    Parameters:\n        url: URL to be opened with urllib\n        timeout: duration in seconds to wait for response. Only works for HTTP, HTTPS &amp; FTP.\n                 Default: `socket._GLOBAL_DEFAULT_TIMEOUT` will be used,\n                 which usually means no timeout.\n    \"\"\"\n    if url in __URL_CONTENT_CACHE:\n        return __URL_CONTENT_CACHE[url]\n\n    with urllib.request.urlopen(url, timeout=timeout) as f:\n        url_content = f.read()\n\n    if isinstance(url_content, bytes):\n        url_content = url_content.decode(\"utf-8\")\n\n    __URL_CONTENT_CACHE[url] = url_content\n    return url_content\n</code></pre>"},{"location":"reference/rdf_utils/collection/","title":"rdf_utils.collection","text":"<p>Functions:</p> <ul> <li> <code>load_list_re</code>             \u2013              <p>Recursively iterate over RDF list containers for extracting lists of lists.</p> </li> </ul>"},{"location":"reference/rdf_utils/collection/#rdf_utils.collection._load_list_re","title":"_load_list_re","text":"<pre><code>_load_list_re(graph, first_node, node_set, parse_uri, quiet)\n</code></pre> <p>Recursive internal function to extract list of lists from RDF list containers.</p> Source code in <code>src/rdf_utils/collection.py</code> <pre><code>def _load_list_re(\n    graph: Graph, first_node: BNode, node_set: set[IdentifiedNode], parse_uri: bool, quiet: bool\n) -&gt; list[Any]:\n    \"\"\"Recursive internal function to extract list of lists from RDF list containers.\"\"\"\n    list_data = []\n    for node in graph.items(list=first_node):\n        if isinstance(node, URIRef):\n            list_data.append(node)\n            continue\n\n        if isinstance(node, Literal):\n            node_val = node.toPython()\n            if not isinstance(node_val, str):\n                list_data.append(node_val)\n                continue\n\n            if not parse_uri:\n                list_data.append(node_val)\n                continue\n\n            # try to expand short-form URIs,\n            # if doesn't work then just return URIRef of the string\n            uri = try_expand_curie(\n                ns_manager=graph.namespace_manager, curie_str=node_val, quiet=quiet\n            )\n            if uri is None:\n                uri = URIRef(node_val)\n\n            list_data.append(uri)\n            continue\n\n        assert isinstance(\n            node, BNode\n        ), f\"load_collections: node '{node}' not a Literal or BNode, type: {type(node)}\"\n\n        if node in node_set:\n            raise RuntimeError(f\"Loop detected in collection at node: {node}\")\n        node_set.add(node)\n\n        # recursive call\n        list_data.append(_load_list_re(graph, node, node_set, parse_uri, quiet))\n\n    return list_data\n</code></pre>"},{"location":"reference/rdf_utils/collection/#rdf_utils.collection.load_list_re","title":"load_list_re","text":"<pre><code>load_list_re(graph, first_node, parse_uri=True, quiet=True)\n</code></pre> <p>Recursively iterate over RDF list containers for extracting lists of lists.</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>Graph object to extract the list(s) from</p> </li> <li> <code>first_node</code>               (<code>BNode</code>)           \u2013            <p>First element in the list</p> </li> <li> <code>parse_uri</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True will try converting literals into URIRef</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True will not throw exceptions other than loop detection</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When a loop is detected</p> </li> <li> <code>ValueError</code>             \u2013            <p>When <code>quiet</code> is <code>False</code> and short URI cannot be expanded</p> </li> </ul> Source code in <code>src/rdf_utils/collection.py</code> <pre><code>def load_list_re(\n    graph: Graph, first_node: BNode, parse_uri: bool = True, quiet: bool = True\n) -&gt; list[Any]:\n    \"\"\"Recursively iterate over RDF list containers for extracting lists of lists.\n\n    Parameters:\n        graph: Graph object to extract the list(s) from\n        first_node: First element in the list\n        parse_uri: if True will try converting literals into URIRef\n        quiet: if True will not throw exceptions other than loop detection\n\n    Raises:\n        RuntimeError: When a loop is detected\n        ValueError: When `quiet` is `False` and short URI cannot be expanded\n    \"\"\"\n    node_set = set()\n\n    return _load_list_re(graph, first_node, node_set, parse_uri, quiet)\n</code></pre>"},{"location":"reference/rdf_utils/constraints/","title":"rdf_utils.constraints","text":"<p>Classes:</p> <ul> <li> <code>ConstraintViolation</code>           \u2013            <p>Exception for domain-specific constraint violation</p> </li> <li> <code>SHACLViolation</code>           \u2013            <p>Specialized exception for SHACL violations</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>check_shacl_constraints</code>             \u2013              <p>Check a graph against a collection of SHACL constraints</p> </li> </ul>"},{"location":"reference/rdf_utils/constraints/#rdf_utils.constraints.ConstraintViolation","title":"ConstraintViolation","text":"<pre><code>ConstraintViolation(domain, message)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Exception for domain-specific constraint violation</p> <p>Attributes:</p> <ul> <li> <code>domain</code>               (<code>str</code>)           \u2013            <p>the violation's domain</p> </li> </ul> Source code in <code>src/rdf_utils/constraints.py</code> <pre><code>def __init__(self, domain: str, message: str):\n    super().__init__(f\"{domain} constraint violated: {message}\")\n    self.domain = domain\n</code></pre>"},{"location":"reference/rdf_utils/constraints/#rdf_utils.constraints.SHACLViolation","title":"SHACLViolation","text":"<pre><code>SHACLViolation(violation_str)\n</code></pre> <p>               Bases: <code>ConstraintViolation</code></p> <p>Specialized exception for SHACL violations</p> Source code in <code>src/rdf_utils/constraints.py</code> <pre><code>def __init__(self, violation_str: str):\n    super().__init__(\"SHACL\", violation_str)\n</code></pre>"},{"location":"reference/rdf_utils/constraints/#rdf_utils.constraints.check_shacl_constraints","title":"check_shacl_constraints","text":"<pre><code>check_shacl_constraints(graph, shacl_dict, quiet=False)\n</code></pre> <p>Check a graph against a collection of SHACL constraints</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>rdflib.Graph to be checked</p> </li> <li> <code>shacl_dict</code>               (<code>dict[str, str]</code>)           \u2013            <p>mapping from SHACL path to graph format, e.g. URL -&gt; \"turtle\"</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if true will not throw an exception</p> </li> </ul> Source code in <code>src/rdf_utils/constraints.py</code> <pre><code>def check_shacl_constraints(graph: Graph, shacl_dict: dict[str, str], quiet:bool = False) -&gt; bool:\n    \"\"\"Check a graph against a collection of SHACL constraints\n\n    Parameters:\n        graph: rdflib.Graph to be checked\n        shacl_dict: mapping from SHACL path to graph format, e.g. URL -&gt; \"turtle\"\n        quiet: if true will not throw an exception\n    \"\"\"\n    shacl_g = Dataset()\n    for mm_url, fmt in shacl_dict.items():\n        shacl_g.parse(mm_url, format=fmt)\n\n    conforms, _, report_text = pyshacl.validate(graph, shacl_graph=shacl_g, inference=\"rdfs\")\n\n    if not conforms and not quiet:\n        raise SHACLViolation(report_text)\n\n    return conforms\n</code></pre>"},{"location":"reference/rdf_utils/namespace/","title":"rdf_utils.namespace","text":"<p>Defining namespaces used by RDF models.</p>"},{"location":"reference/rdf_utils/naming/","title":"rdf_utils.naming","text":"<p>Functions:</p> <ul> <li> <code>get_valid_filename</code>             \u2013              <p>Convert strings to valid file names. Calls <code>get_valid_name</code></p> </li> <li> <code>get_valid_name</code>             \u2013              <p>Return the given string converted to a string that can be used for a clean filename.</p> </li> <li> <code>get_valid_var_name</code>             \u2013              <p>Convert strings to valid variable names. Calls <code>get_valid_name</code></p> </li> </ul>"},{"location":"reference/rdf_utils/naming/#rdf_utils.naming.get_valid_filename","title":"get_valid_filename","text":"<pre><code>get_valid_filename(name)\n</code></pre> <p>Convert strings to valid file names. Calls <code>get_valid_name</code></p> Source code in <code>src/rdf_utils/naming.py</code> <pre><code>def get_valid_filename(name: str) -&gt; str:\n    \"\"\"Convert strings to valid file names. Calls `get_valid_name`\"\"\"\n    return get_valid_name(name, __FILENAME_REPLACEMENTS)\n</code></pre>"},{"location":"reference/rdf_utils/naming/#rdf_utils.naming.get_valid_name","title":"get_valid_name","text":"<pre><code>get_valid_name(name, replacement_dict)\n</code></pre> <p>Return the given string converted to a string that can be used for a clean filename.</p> <p>Based on same function from https://github.com/django/django/blob/main/django/utils/text.py also convert ':' to '__' and '/' to '_'</p> <p>Remove leading and trailing spaces; convert other spaces to underscores; and remove anything that is not an alphanumeric, dash, underscore, or dot.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>String name to be converted</p> </li> <li> <code>replacement_dict</code>               (<code>dict</code>)           \u2013            <p>Maps special characters to acceptable replacements</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_valid_filename(\"john's portrait in 2004.jpg\")\n'johns_portrait_in_2004.jpg'\n</code></pre> Source code in <code>src/rdf_utils/naming.py</code> <pre><code>def get_valid_name(name: str, replacement_dict: dict) -&gt; str:\n    \"\"\"Return the given string converted to a string that can be used for a clean filename.\n\n    Based on same function from https://github.com/django/django/blob/main/django/utils/text.py\n    also convert ':' to '__' and '/' to '_'\n\n    Remove leading and trailing spaces; convert other spaces to underscores;\n    and remove anything that is not an alphanumeric, dash, underscore, or dot.\n\n    Parameters:\n        name: String name to be converted\n        replacement_dict: Maps special characters to acceptable replacements\n\n    Examples:\n        &gt;&gt;&gt; get_valid_filename(\"john's portrait in 2004.jpg\")\n        'johns_portrait_in_2004.jpg'\n    \"\"\"\n    s = str(name).strip()\n    for char in replacement_dict:\n        s = s.replace(char, replacement_dict[char])\n\n    # remove remaining characters\n    s = re.sub(r\"(?u)[^-\\w.]\", \"\", s)\n    if s in {\"\", \".\", \"..\"}:\n        # suspicious file name\n        raise ValueError(f\"Could not derive file name from '{name}'\")\n    return s\n</code></pre>"},{"location":"reference/rdf_utils/naming/#rdf_utils.naming.get_valid_var_name","title":"get_valid_var_name","text":"<pre><code>get_valid_var_name(name)\n</code></pre> <p>Convert strings to valid variable names. Calls <code>get_valid_name</code></p> Source code in <code>src/rdf_utils/naming.py</code> <pre><code>def get_valid_var_name(name: str) -&gt; str:\n    \"\"\"Convert strings to valid variable names. Calls `get_valid_name`\"\"\"\n    return get_valid_name(name, __VAR_NAME_REPLACEMENTS)\n</code></pre>"},{"location":"reference/rdf_utils/resolver/","title":"rdf_utils.resolver","text":"<p>Classes:</p> <ul> <li> <code>IriToFileResolver</code>           \u2013            <p>An <code>OpenerDirector</code> that remaps specific URLs to local files.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>install_resolver</code>             \u2013              <p>Implements default behaviours for resolver installation</p> </li> </ul>"},{"location":"reference/rdf_utils/resolver/#rdf_utils.resolver.IriToFileResolver","title":"IriToFileResolver","text":"<pre><code>IriToFileResolver(url_map, download=True, quiet=False)\n</code></pre> <p>               Bases: <code>OpenerDirector</code></p> <p>An <code>OpenerDirector</code> that remaps specific URLs to local files.</p> <p>Parameters:</p> <ul> <li> <code>url_map</code>               (<code>dict</code>)           \u2013            <p>Mapping from a prefix of a URL to a local location.      For example, <code>{ \"http://example.org/\": \"foo/bar/\" }</code> would remap any      urllib open request for any resource under <code>http://example.org/</code>      to a local directory <code>foo/bar/</code>.</p> </li> <li> <code>download</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true and the mapped local file does not exist, will attempt to download       to the mapped location.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>False</code> and <code>download</code> is <code>True</code> will print where the file will be    downloaded to.</p> </li> </ul> Source code in <code>src/rdf_utils/resolver.py</code> <pre><code>def __init__(self, url_map: dict, download: bool = True, quiet: bool = False):\n    super().__init__()\n    self.default_opener = urllib.request.build_opener()\n    self.url_map = url_map\n    self._download = download\n    self._quiet = quiet\n    self._empty_header = EmailMessage()  # header expected by addinfourl\n</code></pre>"},{"location":"reference/rdf_utils/resolver/#rdf_utils.resolver.install_resolver","title":"install_resolver","text":"<pre><code>install_resolver(resolver=None, url_map=None, download=True, quiet=False)\n</code></pre> <p>Implements default behaviours for resolver installation</p> <p>Parameters:</p> <ul> <li> <code>resolver</code>               (<code>Optional[OpenerDirector]</code>, default:                   <code>None</code> )           \u2013            <p>Resolver to install. If none specified, the default behaviour       (using <code>IriToFileResolver</code>) is to       download the requested files to the user cache directory using       <code>platformdirs</code>.       For Linux this should be <code>$HOME/.cache/rdf-utils/</code>.</p> </li> <li> <code>url_map</code>               (<code>Optional[dict]</code>, default:                   <code>None</code> )           \u2013            <p>URL to local path mapping to pass to      <code>IriToFileResolver</code></p> </li> <li> <code>download</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Download file if true</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Option for more verbose output, created for printing caching location in    <code>IriToFileResolver</code></p> </li> </ul> Note <p>Only a single opener can be globally installed in urllib. Only the latest installed resolver will be active.</p> Source code in <code>src/rdf_utils/resolver.py</code> <pre><code>def install_resolver(\n    resolver: Optional[urllib.request.OpenerDirector] = None,\n    url_map: Optional[dict] = None,\n    download: bool = True,\n    quiet: bool = False,\n) -&gt; None:\n    \"\"\"Implements default behaviours for resolver installation\n\n    Parameters:\n        resolver: Resolver to install. If none specified, the default behaviour\n                  (using [`IriToFileResolver`](rdf_utils.resolver.IriToFileResolver)) is to\n                  download the requested files to the user cache directory using\n                  [`platformdirs`](https://github.com/tox-dev/platformdirs).\n                  For Linux this should be `$HOME/.cache/rdf-utils/`.\n        url_map: URL to local path mapping to pass to\n                 [`IriToFileResolver`](rdf_utils.resolver.IriToFileResolver)\n        download: Download file if true\n        quiet: Option for more verbose output, created for printing caching location in\n               [`IriToFileResolver`](rdf_utils.resolver.IriToFileResolver)\n\n    Note:\n        Only a single opener can be globally installed in urllib.\n        Only the latest installed resolver will be active.\n    \"\"\"\n    if resolver is None:\n        if url_map is None:\n            url_map = {\n                URL_SECORO: join(PKG_CACHE_ROOT, \"secoro\"),\n                URL_COMP_ROB2B: join(PKG_CACHE_ROOT, \"comp-rob2b\"),\n            }\n        resolver = IriToFileResolver(url_map=url_map, download=download, quiet=quiet)\n\n    urllib.request.install_opener(resolver)\n</code></pre>"},{"location":"reference/rdf_utils/uri/","title":"rdf_utils.uri","text":"<p>Functions:</p> <ul> <li> <code>try_expand_curie</code>             \u2013              <p>Execute rdflib <code>expand_curie</code> with exception handling.</p> </li> <li> <code>try_parse_n3_iterable</code>             \u2013              <p>Parse an iterable of N3 strings using rdflib.util.from_n3 with exception handling.</p> </li> <li> <code>try_parse_n3_string</code>             \u2013              <p>Parse N3 string using rdflib.util.from_n3 with exception handling.</p> </li> </ul>"},{"location":"reference/rdf_utils/uri/#rdf_utils.uri.try_expand_curie","title":"try_expand_curie","text":"<pre><code>try_expand_curie(ns_manager, curie_str, quiet=False)\n</code></pre> <p>Execute rdflib <code>expand_curie</code> with exception handling.</p> <p>Parameters:</p> <ul> <li> <code>ns_manager</code>               (<code>NamespaceManager</code>)           \u2013            <p><code>NamespaceManager</code> maps prefixes to namespaces,         usually can use the one in the Graph object.</p> </li> <li> <code>curie_str</code>               (<code>str</code>)           \u2013            <p>The short URI string to be expanded</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If False will raise ValueError, else return None</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[URIRef]</code>           \u2013            <p>Expanded URIRef or None</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>When not <code>quiet</code> and URI cannot be expanded using the given <code>ns_manager</code></p> </li> </ul> Source code in <code>src/rdf_utils/uri.py</code> <pre><code>def try_expand_curie(\n    ns_manager: NamespaceManager, curie_str: str, quiet: bool = False\n) -&gt; Optional[URIRef]:\n    \"\"\"Execute rdflib `expand_curie` with exception handling.\n\n    Parameters:\n        ns_manager: `NamespaceManager` maps prefixes to namespaces,\n                    usually can use the one in the Graph object.\n        curie_str: The short URI string to be expanded\n        quiet: If False will raise ValueError, else return None\n\n    Returns:\n        Expanded URIRef or None\n\n    Raises:\n        ValueError: When not `quiet` and URI cannot be expanded using the given `ns_manager`\n    \"\"\"\n    try:\n        uri = ns_manager.expand_curie(curie_str)\n\n    except ValueError as e:\n        if quiet:\n            return None\n\n        raise ValueError(f\"failed to expand '{curie_str}': {e}\")\n\n    return uri\n</code></pre>"},{"location":"reference/rdf_utils/uri/#rdf_utils.uri.try_parse_n3_iterable","title":"try_parse_n3_iterable","text":"<pre><code>try_parse_n3_iterable(n3_str_iterable, ns_manager, quiet=False)\n</code></pre> <p>Parse an iterable of N3 strings using rdflib.util.from_n3 with exception handling.</p> <p>Parameters:</p> <ul> <li> <code>n3_str_iterable</code>               (<code>Iterable[str]</code>)           \u2013            <p>Iterable of N3 strings to be parsed.</p> </li> <li> <code>ns_manager</code>               (<code>NamespaceManager</code>)           \u2013            <p><code>NamespaceManager</code> maps prefixes to namespaces.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If False will raise ValueError, else return None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>When not <code>quiet</code> and <code>try_parse_n3_string</code> throws an exception</p> </li> </ul> Source code in <code>src/rdf_utils/uri.py</code> <pre><code>def try_parse_n3_iterable(\n    n3_str_iterable: Iterable[str], ns_manager: NamespaceManager, quiet: bool = False\n) -&gt; Optional[list[Union[RDFNode, str]]]:\n    \"\"\"Parse an iterable of N3 strings using rdflib.util.from_n3 with exception handling.\n\n    Parameters:\n        n3_str_iterable: Iterable of N3 strings to be parsed.\n        ns_manager: `NamespaceManager` maps prefixes to namespaces.\n        quiet: If False will raise ValueError, else return None.\n\n    Raises:\n        ValueError: When not `quiet` and `try_parse_n3_string` throws an exception\n    \"\"\"\n    if isinstance(n3_str_iterable, str):\n        res = try_parse_n3_string(n3_str=n3_str_iterable, ns_manager=ns_manager, quiet=quiet)\n        if res is None:\n            return None\n        return [res]\n\n    res_list = []\n    for n3_str in n3_str_iterable:\n        res = try_parse_n3_string(n3_str=n3_str, ns_manager=ns_manager, quiet=quiet)\n        if res is None:\n            return None\n\n        res_list.append(res)\n\n    return res_list\n</code></pre>"},{"location":"reference/rdf_utils/uri/#rdf_utils.uri.try_parse_n3_string","title":"try_parse_n3_string","text":"<pre><code>try_parse_n3_string(n3_str, ns_manager, quiet=False)\n</code></pre> <p>Parse N3 string using rdflib.util.from_n3 with exception handling.</p> <p>Parameters:</p> <ul> <li> <code>n3_str</code>               (<code>str</code>)           \u2013            <p>N3 string to be parsed.</p> </li> <li> <code>ns_manager</code>               (<code>NamespaceManager</code>)           \u2013            <p><code>NamespaceManager</code> maps prefixes to namespaces.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If False will raise ValueError, else return None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>When not <code>quiet</code> and <code>from_n3</code> throws an exception</p> </li> </ul> Source code in <code>src/rdf_utils/uri.py</code> <pre><code>def try_parse_n3_string(\n    n3_str: str, ns_manager: NamespaceManager, quiet: bool = False\n) -&gt; Optional[Union[RDFNode, str]]:\n    \"\"\"Parse N3 string using rdflib.util.from_n3 with exception handling.\n\n    Parameters:\n        n3_str: N3 string to be parsed.\n        ns_manager: `NamespaceManager` maps prefixes to namespaces.\n        quiet: If False will raise ValueError, else return None.\n\n    Raises:\n        ValueError: When not `quiet` and `from_n3` throws an exception\n    \"\"\"\n    res = None\n    try:\n        res = from_n3(s=n3_str, nsm=ns_manager)\n    except Exception as e:\n        if not quiet:\n            raise ValueError(f\"Unable to parse N3 string '{n3_str}', got exception: {e}\")\n    return res\n</code></pre>"},{"location":"reference/rdf_utils/models/","title":"rdf_utils.models","text":"<p>Common processing utilites for RDF graph models</p> <p>Modules:</p> <ul> <li> <code>common</code>           \u2013            </li> <li> <code>distribution</code>           \u2013            </li> <li> <code>event_loop</code>           \u2013            </li> <li> <code>geometry</code>           \u2013            <p>Module for processing geometry models using concepts from</p> </li> <li> <code>python</code>           \u2013            </li> </ul>"},{"location":"reference/rdf_utils/models/common/","title":"rdf_utils.models.common","text":"<p>Classes:</p> <ul> <li> <code>AttrLoaderProtocol</code>           \u2013            <p>Protocol for functions that load model attributes.</p> </li> <li> <code>ModelBase</code>           \u2013            <p>Base object for RDF graph models, enforcing all models to have an URI as ID and types.</p> </li> <li> <code>ModelLoader</code>           \u2013            <p>Class for dynimcally adding functions to load different model attributes.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_node_types</code>             \u2013              <p>Get all types of a node in an RDF graph.</p> </li> </ul>"},{"location":"reference/rdf_utils/models/common/#rdf_utils.models.common.AttrLoaderProtocol","title":"AttrLoaderProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for functions that load model attributes.</p>"},{"location":"reference/rdf_utils/models/common/#rdf_utils.models.common.ModelBase","title":"ModelBase","text":"<pre><code>ModelBase(node_id, graph=None, types=None)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Base object for RDF graph models, enforcing all models to have an URI as ID and types.</p> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>URIRef</code>)           \u2013            <p>the model's ID as an URI</p> </li> <li> <code>types</code>               (<code>set[URIRef]</code>)           \u2013            <p>the model's types</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>node_id</code>               (<code>URIRef</code>)           \u2013            <p>URI of the model node in the graph</p> </li> <li> <code>graph</code>               (<code>Optional[Graph]</code>, default:                   <code>None</code> )           \u2013            <p>RDF graph for loading types if <code>types</code> is not specified</p> </li> <li> <code>types</code>               (<code>Optional[set[URIRef]]</code>, default:                   <code>None</code> )           \u2013            <p>the model's types</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_attr</code>             \u2013              <p>Get an attribute value.</p> </li> <li> <code>has_attr</code>             \u2013              <p>Check if the model has an attribute.</p> </li> <li> <code>set_attr</code>             \u2013              <p>Set an attribute value.</p> </li> </ul> Source code in <code>src/rdf_utils/models/common.py</code> <pre><code>def __init__(\n    self, node_id: URIRef, graph: Optional[Graph] = None, types: Optional[set[URIRef]] = None\n) -&gt; None:\n    self.id = node_id\n    if types is not None:\n        self.types = types\n    else:\n        assert (\n            graph is not None\n        ), f\"ModelBase.__init__: node '{node_id}': neither 'graph' or 'types' specified\"\n        self.types = get_node_types(graph=graph, node_id=node_id)\n    assert len(self.types) &gt; 0, f\"node '{self.id}' has no type\"\n\n    self._attributes = {}\n</code></pre>"},{"location":"reference/rdf_utils/models/common/#rdf_utils.models.common.ModelBase.get_attr","title":"get_attr","text":"<pre><code>get_attr(key)\n</code></pre> <p>Get an attribute value.</p> Source code in <code>src/rdf_utils/models/common.py</code> <pre><code>def get_attr(self, key: URIRef) -&gt; Optional[Any]:\n    \"\"\"Get an attribute value.\"\"\"\n    if key not in self._attributes:\n        return None\n\n    return self._attributes[key]\n</code></pre>"},{"location":"reference/rdf_utils/models/common/#rdf_utils.models.common.ModelBase.has_attr","title":"has_attr","text":"<pre><code>has_attr(key)\n</code></pre> <p>Check if the model has an attribute.</p> Source code in <code>src/rdf_utils/models/common.py</code> <pre><code>def has_attr(self, key: URIRef) -&gt; bool:\n    \"\"\"Check if the model has an attribute.\"\"\"\n    return key in self._attributes\n</code></pre>"},{"location":"reference/rdf_utils/models/common/#rdf_utils.models.common.ModelBase.set_attr","title":"set_attr","text":"<pre><code>set_attr(key, val)\n</code></pre> <p>Set an attribute value.</p> Source code in <code>src/rdf_utils/models/common.py</code> <pre><code>def set_attr(self, key: URIRef, val: Any) -&gt; None:\n    \"\"\"Set an attribute value.\"\"\"\n    self._attributes[key] = val\n</code></pre>"},{"location":"reference/rdf_utils/models/common/#rdf_utils.models.common.ModelLoader","title":"ModelLoader","text":"<pre><code>ModelLoader()\n</code></pre> <p>               Bases: <code>object</code></p> <p>Class for dynimcally adding functions to load different model attributes.</p> <p>Methods:</p> <ul> <li> <code>load_attributes</code>             \u2013              <p>Load all attributes in the graph into a model with the registered loaders.</p> </li> <li> <code>register</code>             \u2013              <p>Add a new attribute loader function.</p> </li> </ul> Source code in <code>src/rdf_utils/models/common.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._loaders = []\n</code></pre>"},{"location":"reference/rdf_utils/models/common/#rdf_utils.models.common.ModelLoader.load_attributes","title":"load_attributes","text":"<pre><code>load_attributes(graph, model, **kwargs)\n</code></pre> <p>Load all attributes in the graph into a model with the registered loaders.</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph for loading attributes</p> </li> <li> <code>model</code>               (<code>ModelBase</code>)           \u2013            <p>Model object to load attributes into</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>any keyword arguments to pass into the loader functions</p> </li> </ul> Source code in <code>src/rdf_utils/models/common.py</code> <pre><code>def load_attributes(self, graph: Graph, model: ModelBase, **kwargs: Any) -&gt; None:\n    \"\"\"Load all attributes in the graph into a model with the registered loaders.\n\n    Parameters:\n        graph: RDF graph for loading attributes\n        model: Model object to load attributes into\n        kwargs: any keyword arguments to pass into the loader functions\n    \"\"\"\n    for loader in self._loaders:\n        loader(graph=graph, model=model, **kwargs)\n</code></pre>"},{"location":"reference/rdf_utils/models/common/#rdf_utils.models.common.ModelLoader.register","title":"register","text":"<pre><code>register(loader)\n</code></pre> <p>Add a new attribute loader function.</p> <p>Parameters:</p> <ul> <li> <code>loader</code>               (<code>AttrLoaderProtocol</code>)           \u2013            <p>attribute loader function</p> </li> </ul> Source code in <code>src/rdf_utils/models/common.py</code> <pre><code>def register(self, loader: AttrLoaderProtocol) -&gt; None:\n    \"\"\"Add a new attribute loader function.\n\n    Parameters:\n        loader: attribute loader function\n    \"\"\"\n    self._loaders.append(loader)\n</code></pre>"},{"location":"reference/rdf_utils/models/common/#rdf_utils.models.common.get_node_types","title":"get_node_types","text":"<pre><code>get_node_types(graph, node_id)\n</code></pre> <p>Get all types of a node in an RDF graph.</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph to look up node types from</p> </li> <li> <code>node_id</code>               (<code>URIRef</code>)           \u2013            <p>URIRef of target node</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>set[URIRef]</code>           \u2013            <p>A set of the node's types as URIRef's</p> </li> </ul> Source code in <code>src/rdf_utils/models/common.py</code> <pre><code>def get_node_types(graph: Graph, node_id: URIRef) -&gt; set[URIRef]:\n    \"\"\"Get all types of a node in an RDF graph.\n\n    Parameters:\n        graph: RDF graph to look up node types from\n        node_id: URIRef of target node\n\n    Returns:\n        A set of the node's types as URIRef's\n    \"\"\"\n    types = set()\n    for type_id in graph.objects(subject=node_id, predicate=RDF.type):\n        assert isinstance(type_id, URIRef), f\"type '{type_id}' of node '{node_id}' not a URIRef\"\n        types.add(type_id)\n    return types\n</code></pre>"},{"location":"reference/rdf_utils/models/distribution/","title":"rdf_utils.models.distribution","text":"<p>Classes:</p> <ul> <li> <code>DistributionModel</code>           \u2013            <p>Model object for probability distributions</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>distrib_from_sampled_quantity</code>             \u2013              <p>Extract a distribution from a :SampledQuantity node through :from-distribution path.</p> </li> <li> <code>sample_from_distrib</code>             \u2013              <p>Sample from a distribution model based on its type.</p> </li> </ul>"},{"location":"reference/rdf_utils/models/distribution/#rdf_utils.models.distribution.DistributionModel","title":"DistributionModel","text":"<pre><code>DistributionModel(distrib_id, graph)\n</code></pre> <p>               Bases: <code>ModelBase</code></p> <p>Model object for probability distributions</p> <p>Attributes:</p> <ul> <li> <code>distrib_type</code>               (<code>URIRef</code>)           \u2013            <p>the type of distribution to be handled</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>distrib_id</code>               (<code>URIRef</code>)           \u2013            <p>URI of the distribution in the graph</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph for loading attributes</p> </li> </ul> Source code in <code>src/rdf_utils/models/distribution.py</code> <pre><code>def __init__(self, distrib_id: URIRef, graph: Graph) -&gt; None:\n    super().__init__(node_id=distrib_id, graph=graph)\n\n    if URI_DISTRIB_TYPE_UNIFORM_ROT in self.types:\n        self.distrib_type = URI_DISTRIB_TYPE_UNIFORM_ROT\n    elif URI_DISTRIB_TYPE_UNIFORM in self.types:\n        self.distrib_type = URI_DISTRIB_TYPE_UNIFORM\n        self._load_uniform_distrib_attrs(graph=graph)\n    elif URI_DISTRIB_TYPE_NORMAL in self.types:\n        self.distrib_type = URI_DISTRIB_TYPE_NORMAL\n        self._load_normal_distrib_attrs(graph=graph)\n    else:\n        raise RuntimeError(f\"Distrib '{self.id}' has unhandled types: {self.types}\")\n</code></pre>"},{"location":"reference/rdf_utils/models/distribution/#rdf_utils.models.distribution.distrib_from_sampled_quantity","title":"distrib_from_sampled_quantity","text":"<pre><code>distrib_from_sampled_quantity(quantity_id, graph)\n</code></pre> <p>Extract a distribution from a :SampledQuantity node through :from-distribution path.</p> <p>Parameters:</p> <ul> <li> <code>quantity_id</code>               (<code>URIRef</code>)           \u2013            <p>URI of the :SampledQuantity node</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph to look for distribution nodes and attributes</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DistributionModel</code>           \u2013            <p>distribution model object</p> </li> </ul> Source code in <code>src/rdf_utils/models/distribution.py</code> <pre><code>def distrib_from_sampled_quantity(quantity_id: URIRef, graph: Graph) -&gt; DistributionModel:\n    \"\"\"Extract a distribution from a :SampledQuantity node through :from-distribution path.\n\n    Parameters:\n        quantity_id: URI of the :SampledQuantity node\n        graph: RDF graph to look for distribution nodes and attributes\n\n    Returns:\n        distribution model object\n    \"\"\"\n    distrib_id = graph.value(subject=quantity_id, predicate=URI_DISTRIB_PRED_FROM_DISTRIB)\n    assert isinstance(\n        distrib_id, URIRef\n    ), f\"Node '{quantity_id}' does not link to a distribution node: {distrib_id}\"\n    return DistributionModel(distrib_id=distrib_id, graph=graph)\n</code></pre>"},{"location":"reference/rdf_utils/models/distribution/#rdf_utils.models.distribution.sample_from_distrib","title":"sample_from_distrib","text":"<pre><code>sample_from_distrib(distrib, size=None)\n</code></pre> <p>Sample from a distribution model based on its type.</p> <p>Parameters:</p> <ul> <li> <code>distrib</code>               (<code>DistributionModel</code>)           \u2013            <p>distribution model</p> </li> <li> <code>size</code>               (<code>Optional[int | tuple[int, ...]]</code>, default:                   <code>None</code> )           \u2013            <p>Size of the sample, which matches size argument in numpy.random calls.   Will be ignored for random rotations at the moment. For uniform and normal distribs,   tuple size should have last dimension matching the distrib's dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>distribution sample with dimension matching given size</p> </li> </ul> Source code in <code>src/rdf_utils/models/distribution.py</code> <pre><code>def sample_from_distrib(\n    distrib: DistributionModel, size: Optional[int | tuple[int, ...]] = None\n) -&gt; Any:\n    \"\"\"Sample from a distribution model based on its type.\n\n    Parameters:\n        distrib: distribution model\n        size: Size of the sample, which matches size argument in numpy.random calls.\n              Will be ignored for random rotations at the moment. For uniform and normal distribs,\n              tuple size should have last dimension matching the distrib's dimension.\n\n    Returns:\n        distribution sample with dimension matching given size\n    \"\"\"\n    if URI_DISTRIB_TYPE_UNIFORM_ROT in distrib.types:\n        try:\n            from scipy.spatial.transform import Rotation\n        except ImportError:\n            raise RuntimeError(\"to sample random rotations, 'scipy' must be installed\")\n\n        return Rotation.random()\n\n    if URI_DISTRIB_TYPE_UNIFORM in distrib.types:\n        lower_bounds = distrib.get_attr(key=URI_DISTRIB_PRED_LOWER)\n        upper_bounds = distrib.get_attr(key=URI_DISTRIB_PRED_UPPER)\n        assert isinstance(lower_bounds, list) and isinstance(\n            upper_bounds, list\n        ), f\"Uniform distrib '{distrib.id}' does not have valid lower &amp; upper bounds\"\n        return np.random.uniform(lower_bounds, upper_bounds, size=size)\n\n    if URI_DISTRIB_TYPE_NORMAL in distrib.types:\n        dim = distrib.get_attr(key=URI_DISTRIB_PRED_DIM)\n        assert (\n            isinstance(dim, int) and dim &gt; 0\n        ), f\"Normal distrib '{distrib.id}' does not have valid dimension: {dim}\"\n\n        mean = distrib.get_attr(key=URI_DISTRIB_PRED_MEAN)\n        assert (\n            isinstance(mean, list) and len(mean) == dim\n        ), f\"Normal distrib '{distrib.id}' does not have valid mean: {mean}\"\n\n        if dim == 1:\n            std = distrib.get_attr(key=URI_DISTRIB_PRED_STD)\n            assert isinstance(\n                std, float\n            ), f\"Normal distrib '{distrib.id}' does not have valid standard deviation: {std}\"\n            return np.random.normal(loc=mean[0], scale=std, size=size)\n\n        # multivariate normal\n        cov = distrib.get_attr(key=URI_DISTRIB_PRED_COV)\n        assert isinstance(\n            cov, np.ndarray\n        ), f\"Normal distrib '{distrib.id}' does not have valid covariance: {cov}\"\n        return np.random.multivariate_normal(mean=mean, cov=cov, size=size)\n\n    raise RuntimeError(f\"Distrib '{distrib.id}' has unhandled types: {distrib.types}\")\n</code></pre>"},{"location":"reference/rdf_utils/models/event_loop/","title":"rdf_utils.models.event_loop","text":"<p>Classes:</p> <ul> <li> <code>EventLoopModel</code>           \u2013            <p>Model of an event loop containing models of reactions to events and flags.</p> </li> <li> <code>EventReactionModel</code>           \u2013            <p>Model for reactions to an event.</p> </li> <li> <code>FlagReactionModel</code>           \u2013            <p>Model for reactions to a flag.</p> </li> </ul>"},{"location":"reference/rdf_utils/models/event_loop/#rdf_utils.models.event_loop.EventLoopModel","title":"EventLoopModel","text":"<pre><code>EventLoopModel(el_id, graph)\n</code></pre> <p>               Bases: <code>ModelBase</code></p> <p>Model of an event loop containing models of reactions to events and flags.</p> <p>Attributes:</p> <ul> <li> <code>events_triggered</code>               (<code>dict[URIRef, bool]</code>)           \u2013            <p>if true should notify that an event is triggered in the last loop</p> </li> <li> <code>flag_values</code>               (<code>dict[URIRef, bool]</code>)           \u2013            <p>value of flag in the last loop</p> </li> <li> <code>event_reactions</code>               (<code>dict[URIRef, EventReactionModel]</code>)           \u2013            <p>reaction models to events</p> </li> <li> <code>flag_reactions</code>               (<code>dict[URIRef, FlagReactionModel]</code>)           \u2013            <p>reaction models to flags</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>el_id</code>               (<code>URIRef</code>)           \u2013            <p>URI of event loop</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>graph for loading attributes</p> </li> </ul> Source code in <code>src/rdf_utils/models/event_loop.py</code> <pre><code>def __init__(self, el_id: URIRef, graph: Graph) -&gt; None:\n    super().__init__(node_id=el_id, graph=graph)\n\n    self.events_triggered = {}\n    self.flag_values = {}\n    self.event_reactions = {}\n    self.flag_reactions = {}\n\n    for evt_uri in graph.objects(subject=self.id, predicate=URI_EL_PRED_HAS_EVT):\n        assert isinstance(\n            evt_uri, URIRef\n        ), f\"Event '{evt_uri}' is not of type URIRef: {type(evt_uri)}\"\n        self.events_triggered[evt_uri] = False\n\n    for flg_uri in graph.objects(subject=self.id, predicate=URI_EL_PRED_HAS_FLG):\n        assert isinstance(\n            flg_uri, URIRef\n        ), f\"Flag '{flg_uri}' is not of type URIRef: {type(flg_uri)}\"\n        self.flag_values[flg_uri] = False\n\n    for evt_re_uri in graph.objects(subject=self.id, predicate=URI_EL_PRED_HAS_EVT_REACT):\n        assert isinstance(\n            evt_re_uri, URIRef\n        ), f\"EventReaction '{evt_re_uri}' is not of type URIRef: {type(evt_re_uri)}\"\n        evt_re_model = EventReactionModel(reaction_id=evt_re_uri, graph=graph)\n        assert (\n            evt_re_model.event_id in self.events_triggered\n        ), f\"'{evt_re_model.id}' reacts to event '{evt_re_model.event_id}', which is not in event loop '{self.id}'\"\n        self.event_reactions[evt_re_model.event_id] = evt_re_model\n\n    for flg_re_uri in graph.objects(subject=self.id, predicate=URI_EL_PRED_HAS_FLG_REACT):\n        assert isinstance(\n            flg_re_uri, URIRef\n        ), f\"FlagReaction '{flg_re_uri}' is not of type URIRef: {type(flg_re_uri)}\"\n        flg_re_model = FlagReactionModel(reaction_id=flg_re_uri, graph=graph)\n        assert (\n            flg_re_model.flag_id in self.flag_values\n        ), f\"'{flg_re_model.id}' reacts to flag '{flg_re_model.flag_id}', which is not in event loop '{self.id}'\"\n        self.flag_reactions[flg_re_model.flag_id] = flg_re_model\n</code></pre>"},{"location":"reference/rdf_utils/models/event_loop/#rdf_utils.models.event_loop.EventReactionModel","title":"EventReactionModel","text":"<pre><code>EventReactionModel(reaction_id, graph)\n</code></pre> <p>               Bases: <code>ModelBase</code></p> <p>Model for reactions to an event.</p> <p>Attributes:</p> <ul> <li> <code>event_id</code>               (<code>URIRef</code>)           \u2013            <p>URI of the event to react to</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>reaction_id</code>               (<code>URIRef</code>)           \u2013            <p>URI of the reaction model</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph to load relevant attributes</p> </li> </ul> Source code in <code>src/rdf_utils/models/event_loop.py</code> <pre><code>def __init__(self, reaction_id: URIRef, graph: Graph) -&gt; None:\n    super().__init__(node_id=reaction_id, graph=graph)\n\n    evt_uri = graph.value(subject=self.id, predicate=URI_EL_PRED_REF_EVT)\n    assert evt_uri is not None and isinstance(\n        evt_uri, URIRef\n    ), f\"EventReaction '{self.id}' does not refer to a valid event URI: {evt_uri}\"\n    self.event_id = evt_uri\n</code></pre>"},{"location":"reference/rdf_utils/models/event_loop/#rdf_utils.models.event_loop.FlagReactionModel","title":"FlagReactionModel","text":"<pre><code>FlagReactionModel(reaction_id, graph)\n</code></pre> <p>               Bases: <code>ModelBase</code></p> <p>Model for reactions to a flag.</p> <p>Attributes:</p> <ul> <li> <code>flag_id</code>               (<code>URIRef</code>)           \u2013            <p>URI of the flag to react to</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>reaction_id</code>               (<code>URIRef</code>)           \u2013            <p>URI of the reaction model</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph to load relevant attributes</p> </li> </ul> Source code in <code>src/rdf_utils/models/event_loop.py</code> <pre><code>def __init__(self, reaction_id: URIRef, graph: Graph) -&gt; None:\n    super().__init__(node_id=reaction_id, graph=graph)\n\n    flg_uri = graph.value(subject=self.id, predicate=URI_EL_PRED_REF_FLG)\n    assert flg_uri is not None and isinstance(\n        flg_uri, URIRef\n    ), f\"FlagReaction '{self.id}' does not refer to a valid flag URI: {flg_uri}\"\n    self.flag_id = flg_uri\n</code></pre>"},{"location":"reference/rdf_utils/models/geometry/","title":"rdf_utils.models.geometry","text":"<p>Module for processing geometry models using concepts from comp-rob2b and ones introduced for use by the SECORO group.</p> <p>Classes:</p> <ul> <li> <code>FrameModel</code>           \u2013            <p>Model object for a Frame</p> </li> <li> <code>PoseCoordModel</code>           \u2013            <p>Model object for a PoseCoordinate</p> </li> <li> <code>PositionCoordModel</code>           \u2013            <p>Model object for a PoseCoordinate</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_coord_vectorxyz</code>             \u2013              <p>Extract coordinates for a VectorXYZ model.</p> </li> <li> <code>get_euler_angles_abg</code>             \u2013              <p>Extract coordinates for a AnglesAlphaBetaGamma model.</p> </li> <li> <code>get_euler_angles_params</code>             \u2013              <p>Extract parameters for a EulerAngles model.</p> </li> <li> <code>get_scipy_rotation</code>             \u2013              <p>Parse orientation coordinate in a graph into a SciPy Rotation.</p> </li> </ul>"},{"location":"reference/rdf_utils/models/geometry/#rdf_utils.models.geometry.FrameModel","title":"FrameModel","text":"<pre><code>FrameModel(frame_id, graph)\n</code></pre> <p>               Bases: <code>ModelBase</code></p> <p>Model object for a Frame</p> <p>Attributes:</p> <ul> <li> <code>origin</code>               (<code>URIRef</code>)           \u2013            <p>URI for origin Point of the Frame</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>frame_id</code>               (<code>URIRef</code>)           \u2013            <p>URI of the frame in the graph</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph for loading attributes</p> </li> </ul> Source code in <code>src/rdf_utils/models/geometry.py</code> <pre><code>def __init__(self, frame_id: URIRef, graph: Graph) -&gt; None:\n    super().__init__(node_id=frame_id, graph=graph)\n\n    origin_id = graph.value(subject=self.id, predicate=URI_GEOM_PRED_ORIGIN)\n    assert origin_id is not None and isinstance(\n        origin_id, URIRef\n    ), f\"Frame '{self.id}' does not have a valid 'origin' property: {origin_id}\"\n    self.origin = origin_id\n</code></pre>"},{"location":"reference/rdf_utils/models/geometry/#rdf_utils.models.geometry.PoseCoordModel","title":"PoseCoordModel","text":"<pre><code>PoseCoordModel(coord_id, graph)\n</code></pre> <p>               Bases: <code>ModelBase</code></p> <p>Model object for a PoseCoordinate</p> <p>Attributes:</p> <ul> <li> <code>pose</code>               (<code>URIRef</code>)           \u2013            <p>URI of Pose of the coordinate</p> </li> <li> <code>of</code>               (<code>FrameModel</code>)           \u2013            <p>the pose's target frame</p> </li> <li> <code>wrt</code>               (<code>FrameModel</code>)           \u2013            <p>the pose's reference frame</p> </li> <li> <code>as_seen_by</code>               (<code>URIRef</code>)           \u2013            <p>the coordinate's reference frame</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>coord_id</code>               (<code>URIRef</code>)           \u2013            <p>URI of the PoseCoordinate in the graph</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph for loading attributes</p> </li> </ul> Source code in <code>src/rdf_utils/models/geometry.py</code> <pre><code>def __init__(self, coord_id: URIRef, graph: Graph) -&gt; None:\n    super().__init__(node_id=coord_id, graph=graph)\n\n    assert URI_GEOM_TYPE_POSE_COORD in self.types, f\"'{self.id}' is not a PoseCoordinate\"\n\n    seen_by_id = graph.value(subject=self.id, predicate=URI_GEOM_PRED_SEEN_BY)\n    assert seen_by_id is not None and isinstance(\n        seen_by_id, URIRef\n    ), f\"PoseCoordinate '{self.id}' does not have a valid 'as-seen-by' property: {seen_by_id}\"\n    self.as_seen_by = seen_by_id\n\n    assert URI_GEOM_TYPE_POSE_REF in self.types, f\"'{self.id}' is not a PoseReference\"\n    pose_id = graph.value(subject=self.id, predicate=URI_GEOM_PRED_OF_POSE)\n    assert pose_id is not None and isinstance(\n        pose_id, URIRef\n    ), f\"PoseCoordinate '{self.id}' does not have a valid 'of-pose' property: {pose_id}\"\n    self.pose = pose_id\n\n    of_id = graph.value(subject=self.pose, predicate=URI_GEOM_PRED_OF)\n    assert of_id is not None and isinstance(\n        of_id, URIRef\n    ), f\"Pose '{self.pose}' does not have a valid 'of' property: {of_id}\"\n    self.of = FrameModel(frame_id=of_id, graph=graph)\n\n    wrt_id = graph.value(subject=self.pose, predicate=URI_GEOM_PRED_WRT)\n    assert wrt_id is not None and isinstance(\n        wrt_id, URIRef\n    ), f\"Pose '{self.pose}' does not have a valid 'with-respect-to' property: {wrt_id}\"\n    self.wrt = FrameModel(frame_id=wrt_id, graph=graph)\n</code></pre>"},{"location":"reference/rdf_utils/models/geometry/#rdf_utils.models.geometry.PositionCoordModel","title":"PositionCoordModel","text":"<pre><code>PositionCoordModel(coord_id, graph)\n</code></pre> <p>               Bases: <code>ModelBase</code></p> <p>Model object for a PoseCoordinate</p> <p>Attributes:</p> <ul> <li> <code>position</code>               (<code>URIRef</code>)           \u2013            <p>URI of Position of the coordinate</p> </li> <li> <code>of</code>               (<code>URIRef</code>)           \u2013            <p>URI of the position's target Point</p> </li> <li> <code>wrt</code>               (<code>URIRef</code>)           \u2013            <p>URI of the position's reference Point</p> </li> <li> <code>as_seen_by</code>               (<code>URIRef</code>)           \u2013            <p>the coordinate's reference frame</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>coord_id</code>               (<code>URIRef</code>)           \u2013            <p>URI of the PositionCoordinate in the graph</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph for loading attributes</p> </li> </ul> Source code in <code>src/rdf_utils/models/geometry.py</code> <pre><code>def __init__(self, coord_id: URIRef, graph: Graph) -&gt; None:\n    super().__init__(node_id=coord_id, graph=graph)\n\n    assert (\n        URI_GEOM_TYPE_POSITION_COORD in self.types\n    ), f\"'{self.id}' is not a PositionCoordinate\"\n\n    seen_by_id = graph.value(subject=self.id, predicate=URI_GEOM_PRED_SEEN_BY)\n    assert (\n        seen_by_id is not None and isinstance(seen_by_id, URIRef)\n    ), f\"PositionCoordinate '{self.id}' does not have a valid 'as-seen-by' property: {seen_by_id}\"\n    self.as_seen_by = seen_by_id\n\n    assert URI_GEOM_TYPE_POSITION_REF in self.types, f\"'{self.id}' is not a PositionReference\"\n    position_id = graph.value(subject=self.id, predicate=URI_GEOM_PRED_OF_POSITION)\n    assert (\n        position_id is not None and isinstance(position_id, URIRef)\n    ), f\"PositionCoordinate '{self.id}' does not have a valid 'of-position' property: {position_id}\"\n    self.position = position_id\n\n    of_id = graph.value(subject=self.position, predicate=URI_GEOM_PRED_OF)\n    assert of_id is not None and isinstance(\n        of_id, URIRef\n    ), f\"Position '{self.position}' does not have a valid 'of' property: {of_id}\"\n    self.of = of_id\n\n    wrt_id = graph.value(subject=self.position, predicate=URI_GEOM_PRED_WRT)\n    assert wrt_id is not None and isinstance(\n        wrt_id, URIRef\n    ), f\"Position '{self.position}' does not have a valid 'with-respect-to' property: {wrt_id}\"\n    self.wrt = wrt_id\n</code></pre>"},{"location":"reference/rdf_utils/models/geometry/#rdf_utils.models.geometry.get_coord_vectorxyz","title":"get_coord_vectorxyz","text":"<pre><code>get_coord_vectorxyz(coord_model, graph)\n</code></pre> <p>Extract coordinates for a VectorXYZ model.</p> <p>Parameters:</p> <ul> <li> <code>coord_model</code>               (<code>ModelBase</code>)           \u2013            <p>coordinate model object</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph to look for coordinate attributes</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float, float]</code>           \u2013            <p>tuple containing (x, y, z) coordinates</p> </li> </ul> Source code in <code>src/rdf_utils/models/geometry.py</code> <pre><code>def get_coord_vectorxyz(coord_model: ModelBase, graph: Graph) -&gt; tuple[float, float, float]:\n    \"\"\"Extract coordinates for a VectorXYZ model.\n\n    Parameters:\n        coord_model: coordinate model object\n        graph: RDF graph to look for coordinate attributes\n\n    Returns:\n        tuple containing (x, y, z) coordinates\n    \"\"\"\n    assert (\n        URI_GEOM_TYPE_VECTOR_XYZ in coord_model.types\n    ), f\"Coordinate '{coord_model.id}' is not of type 'VectorXYZ'\"\n\n    x_node = graph.value(subject=coord_model.id, predicate=URI_GEOM_PRED_X)\n    assert isinstance(x_node, Literal) and isinstance(\n        x_node.value, float\n    ), f\"Coordinate '{coord_model.id}' does not have a 'x' property of type float: {x_node}\"\n\n    y_node = graph.value(subject=coord_model.id, predicate=URI_GEOM_PRED_Y)\n    assert isinstance(y_node, Literal) and isinstance(\n        y_node.value, float\n    ), f\"Coordinate '{coord_model.id}' does not have a 'y' property of type float: {y_node}\"\n\n    z_node = graph.value(subject=coord_model.id, predicate=URI_GEOM_PRED_Z)\n    assert isinstance(z_node, Literal) and isinstance(\n        z_node.value, float\n    ), f\"Coordinate '{coord_model.id}' does not have a 'z' property of type float: {z_node}\"\n\n    return (x_node.value, y_node.value, z_node.value)\n</code></pre>"},{"location":"reference/rdf_utils/models/geometry/#rdf_utils.models.geometry.get_euler_angles_abg","title":"get_euler_angles_abg","text":"<pre><code>get_euler_angles_abg(coord_model, graph)\n</code></pre> <p>Extract coordinates for a AnglesAlphaBetaGamma model.</p> <p>Parameters:</p> <ul> <li> <code>coord_model</code>               (<code>PoseCoordModel</code>)           \u2013            <p>coordinate model object, currently only handle PoseCoordModel</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph to look for coordinate attributes</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>tuple containing:</p> </li> <li> <code>bool</code>           \u2013            <ul> <li>axes sequence of the Euler angles</li> </ul> </li> <li> <code>URIRef</code>           \u2013            <ul> <li>whether the rotation is intrinsic</li> </ul> </li> <li> <code>tuple[float, float, float]</code>           \u2013            <ul> <li>unit of the angle values (degrees or radians)</li> </ul> </li> <li> <code>tuple[str, bool, URIRef, tuple[float, float, float]]</code>           \u2013            <ul> <li>angle values</li> </ul> </li> </ul> Source code in <code>src/rdf_utils/models/geometry.py</code> <pre><code>def get_euler_angles_abg(\n    coord_model: PoseCoordModel, graph: Graph\n) -&gt; tuple[str, bool, URIRef, tuple[float, float, float]]:\n    \"\"\"Extract coordinates for a AnglesAlphaBetaGamma model.\n\n    Parameters:\n        coord_model: coordinate model object, currently only handle PoseCoordModel\n        graph: RDF graph to look for coordinate attributes\n\n    Returns:\n        tuple containing:\n        - axes sequence of the Euler angles\n        - whether the rotation is intrinsic\n        - unit of the angle values (degrees or radians)\n        - angle values\n    \"\"\"\n    assert (\n        URI_GEOM_TYPE_ANGLES_ABG in coord_model.types\n    ), f\"coord '{coord_model.id}' does not have type 'AnglesAlphaBetaGamma'\"\n\n    seq, is_intrinsic = get_euler_angles_params(coord_model=coord_model, graph=graph)\n\n    a_node = graph.value(subject=coord_model.id, predicate=URI_GEOM_PRED_ALPHA)\n    assert isinstance(a_node, Literal) and isinstance(\n        a_node.value, float\n    ), f\"Coordinate '{coord_model.id}' does not have a 'alpha' property of type float: {a_node}\"\n\n    b_node = graph.value(subject=coord_model.id, predicate=URI_GEOM_PRED_BETA)\n    assert isinstance(b_node, Literal) and isinstance(\n        b_node.value, float\n    ), f\"Coordinate '{coord_model.id}' does not have a 'beta' property of type float: {b_node}\"\n\n    g_node = graph.value(subject=coord_model.id, predicate=URI_GEOM_PRED_GAMMA)\n    assert isinstance(g_node, Literal) and isinstance(\n        g_node.value, float\n    ), f\"Coordinate '{coord_model.id}' does not have a 'gamma' property of type float: {g_node}\"\n\n    angle_unit = None\n    for unit_node in graph.objects(subject=coord_model.id, predicate=URI_QUDT_PRED_UNIT):\n        assert isinstance(\n            unit_node, URIRef\n        ), f\"Coordinate '{coord_model.id}' does not ref a URI 'unit': {unit_node}\"\n        if unit_node != URI_QUDT_TYPE_DEG and unit_node != URI_QUDT_TYPE_RAD:\n            continue\n        angle_unit = unit_node\n        break\n\n    assert angle_unit is not None, f\"Coordinate '{coord_model.id}' has invalid angle unit\"\n\n    return seq, is_intrinsic, angle_unit, (a_node.value, b_node.value, g_node.value)\n</code></pre>"},{"location":"reference/rdf_utils/models/geometry/#rdf_utils.models.geometry.get_euler_angles_params","title":"get_euler_angles_params","text":"<pre><code>get_euler_angles_params(coord_model, graph)\n</code></pre> <p>Extract parameters for a EulerAngles model.</p> <p>Parameters:</p> <ul> <li> <code>coord_model</code>               (<code>PoseCoordModel</code>)           \u2013            <p>coordinate model object, currently only handle PoseCoordModel</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph to look for coordinate attributes</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[str, bool]</code>           \u2013            <p>tuple containing axes sequence of the Euler angles and whether the rotation is intrinsic</p> </li> </ul> Source code in <code>src/rdf_utils/models/geometry.py</code> <pre><code>def get_euler_angles_params(coord_model: PoseCoordModel, graph: Graph) -&gt; tuple[str, bool]:\n    \"\"\"Extract parameters for a EulerAngles model.\n\n    Parameters:\n        coord_model: coordinate model object, currently only handle PoseCoordModel\n        graph: RDF graph to look for coordinate attributes\n\n    Returns:\n        tuple containing axes sequence of the Euler angles and whether the rotation is intrinsic\n    \"\"\"\n    assert (\n        URI_GEOM_TYPE_EULER_ANGLES in coord_model.types\n    ), f\"coord '{coord_model.id}' does not have type 'EulerAngles'\"\n\n    if URI_GEOM_TYPE_INTRINSIC in coord_model.types:\n        is_intrinsic = True\n    elif URI_GEOM_TYPE_EXTRINSIC in coord_model.types:\n        is_intrinsic = False\n    else:\n        raise ConstraintViolation(\n            domain=\"geometry\",\n            message=f\"EulerAngles coord '{coord_model.id}' does not have 'Intrinsic' or 'Extrinsic' type\",\n        )\n\n    seq_node = graph.value(subject=coord_model.id, predicate=URI_GEOM_PRED_AXES_SEQ)\n    assert (\n        isinstance(seq_node, Literal) and isinstance(seq_node.value, str)\n    ), f\"Coordinate '{coord_model.id}' does not have a 'axes-sequence' property of type str: {seq_node}\"\n\n    return seq_node.value, is_intrinsic\n</code></pre>"},{"location":"reference/rdf_utils/models/geometry/#rdf_utils.models.geometry.get_scipy_rotation","title":"get_scipy_rotation","text":"<pre><code>get_scipy_rotation(coord_model, graph)\n</code></pre> <p>Parse orientation coordinate in a graph into a SciPy Rotation.</p> <p>Handles and convert different orientation coordinate types into a SciPy Rotation</p> <p>Parameters:</p> <ul> <li> <code>coord_model</code>               (<code>PoseCoordModel</code>)           \u2013            <p>coordinate model object, currently only handle PoseCoordModel</p> </li> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph to look for coordinate attributes</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Rotation</code>           \u2013            <p>Corresponding SciPy Rotation</p> </li> </ul> Source code in <code>src/rdf_utils/models/geometry.py</code> <pre><code>def get_scipy_rotation(coord_model: PoseCoordModel, graph: Graph) -&gt; Rotation:\n    \"\"\"Parse orientation coordinate in a graph into a SciPy Rotation.\n\n    Handles and convert different orientation coordinate types into a\n    [SciPy Rotation](scipy.spatial.transform.Rotation)\n\n    Parameters:\n        coord_model: coordinate model object, currently only handle PoseCoordModel\n        graph: RDF graph to look for coordinate attributes\n\n    Returns:\n        Corresponding [SciPy Rotation](scipy.spatial.transform.Rotation)\n    \"\"\"\n    if URI_GEOM_TYPE_ANGLES_ABG in coord_model.types:\n        seq, is_intrinsic, unit, angles = get_euler_angles_abg(coord_model=coord_model, graph=graph)\n        if is_intrinsic:\n            seq = seq.upper()\n        return Rotation.from_euler(seq=seq, angles=angles, degrees=(unit == URI_QUDT_TYPE_DEG))\n    else:\n        raise RuntimeError(\n            f\"unhandled orientation coordinate type for '{coord_model.id}', types: {coord_model.types}\"\n        )\n</code></pre>"},{"location":"reference/rdf_utils/models/python/","title":"rdf_utils.models.python","text":"<p>Functions:</p> <ul> <li> <code>import_attr_from_model</code>             \u2013              <p>Import a Python module's attribute from a model object.</p> </li> <li> <code>import_attr_from_node</code>             \u2013              <p>Import a Python module's attribute from an RDF graph using importlib</p> </li> <li> <code>load_py_module_attr</code>             \u2013              <p>Load relevant attributes of a <code>ModuleAttribute</code> node into a model object.</p> </li> </ul>"},{"location":"reference/rdf_utils/models/python/#rdf_utils.models.python.import_attr_from_model","title":"import_attr_from_model","text":"<pre><code>import_attr_from_model(model)\n</code></pre> <p>Import a Python module's attribute from a model object. Assuming <code>load_py_module_attr</code> was already called on the object.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>ModelBase</code>)           \u2013            <p>Model object containing relevant info for a <code>ModuleAttribute</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The module attribute, e.g. class or function</p> </li> </ul> Source code in <code>src/rdf_utils/models/python.py</code> <pre><code>def import_attr_from_model(model: ModelBase) -&gt; Any:\n    \"\"\"Import a Python module's attribute from a model object.\n    Assuming `load_py_module_attr` was already called on the object.\n\n    Parameters:\n        model: Model object containing relevant info for a `ModuleAttribute`\n\n    Returns:\n        The module attribute, e.g. class or function\n    \"\"\"\n    assert (\n        URI_PY_TYPE_MODULE_ATTR in model.types\n    ), f\"model '{model.id}' doesn't have type '{URI_PY_TYPE_MODULE_ATTR}'\"\n\n    module_name = model.get_attr(key=URI_PY_PRED_MODULE_NAME)\n    assert module_name is not None, f\"module name not loaded for ModuleAttribute '{model.id}'\"\n\n    attr_name = model.get_attr(key=URI_PY_PRED_ATTR_NAME)\n    assert attr_name is not None, f\"attribute name not loaded for ModuleAttribute '{model.id}'\"\n\n    return getattr(import_module(module_name), attr_name, None)\n</code></pre>"},{"location":"reference/rdf_utils/models/python/#rdf_utils.models.python.import_attr_from_node","title":"import_attr_from_node","text":"<pre><code>import_attr_from_node(graph, uri)\n</code></pre> <p>Import a Python module's attribute from an RDF graph using importlib</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph to load relevant info</p> </li> <li> <code>uri</code>               (<code>URIRef | str</code>)           \u2013            <p>URI of the <code>ModuleAttribute</code> node</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The module attribute, e.g. class or function</p> </li> </ul> Source code in <code>src/rdf_utils/models/python.py</code> <pre><code>def import_attr_from_node(graph: Graph, uri: URIRef | str) -&gt; Any:\n    \"\"\"Import a Python module's attribute from an RDF graph using importlib\n\n    Parameters:\n        graph: RDF graph to load relevant info\n        uri: URI of the `ModuleAttribute` node\n\n    Returns:\n        The module attribute, e.g. class or function\n    \"\"\"\n    if isinstance(uri, str):\n        uri = URIRef(uri)\n\n    module_name = str(graph.value(uri, URI_PY_PRED_MODULE_NAME))\n    attr_name = str(graph.value(uri, URI_PY_PRED_ATTR_NAME))\n\n    return getattr(import_module(module_name), attr_name, None)\n</code></pre>"},{"location":"reference/rdf_utils/models/python/#rdf_utils.models.python.load_py_module_attr","title":"load_py_module_attr","text":"<pre><code>load_py_module_attr(graph, model, quiet=True, **kwargs)\n</code></pre> <p>Load relevant attributes of a <code>ModuleAttribute</code> node into a model object.</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>RDF graph to load relevant info.</p> </li> <li> <code>model</code>               (<code>ModelBase</code>)           \u2013            <p>The model object.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True won't raise an exception</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>if not quiet and model object does not have <code>ModuleAttribute</code> type</p> </li> </ul> Source code in <code>src/rdf_utils/models/python.py</code> <pre><code>def load_py_module_attr(graph: Graph, model: ModelBase, quiet: bool = True, **kwargs: Any) -&gt; None:\n    \"\"\"Load relevant attributes of a `ModuleAttribute` node into a model object.\n\n    Parameters:\n        graph: RDF graph to load relevant info.\n        model: The model object.\n        quiet: If True won't raise an exception\n\n    Raises:\n        RuntimeError: if not quiet and model object does not have `ModuleAttribute` type\n    \"\"\"\n    if URI_PY_TYPE_MODULE_ATTR not in model.types:\n        if quiet:\n            return\n        raise RuntimeError(f\"load_py_module_attr: '{model.id}' is not a {URI_PY_TYPE_MODULE_ATTR}\")\n\n    module_name = graph.value(model.id, URI_PY_PRED_MODULE_NAME)\n    assert (\n        module_name is not None\n    ), f\"ModuleAttribute '{model.id}' doesn't have attr '{URI_PY_PRED_MODULE_NAME}'\"\n    model.set_attr(key=URI_PY_PRED_MODULE_NAME, val=str(module_name))\n\n    attr_name = graph.value(model.id, URI_PY_PRED_ATTR_NAME)\n    assert (\n        attr_name is not None\n    ), f\"ModuleAttribute '{model.id}' doesn't have attr '{URI_PY_PRED_ATTR_NAME}'\"\n    model.set_attr(key=URI_PY_PRED_ATTR_NAME, val=str(attr_name))\n</code></pre>"}]}